#include "gmock/gmock.h"
#include "TestApp.h"
#include "GTestFENonlinearProblem.h"
#include "GTest2FieldsFENonlinearProblem.h"
#include "godzilla/Factory.h"
#include "godzilla/MeshFactory.h"
#include "godzilla/LineMesh.h"
#include "godzilla/BoxMesh.h"
#include "godzilla/EssentialBC.h"

using namespace godzilla;
using namespace testing;

namespace {

class DirichletBC : public EssentialBC {
public:
    explicit DirichletBC(const Parameters & pars) : EssentialBC(pars) {}

    void
    evaluate(Real time, const Real x[], Scalar u[]) override
    {
        u[0] = time * (x[0] + x[1] + x[2]);
    }

    void
    evaluate_t(Real time, const Real x[], Scalar u[]) override
    {
        u[0] = 1.;
    }

    std::vector<Int>
    create_components() override
    {
        return { 0 };
    }
};

} // namespace

TEST(EssentialBCTest, test)
{
    TestApp app;

    auto mesh_pars = BoxMesh::parameters();
    // clang-format off
    mesh_pars
        .set<App *>("_app", &app)
        .set<Int>("nx", 2)
        .set<Int>("ny", 2)
        .set<Int>("nz", 2);
    // clang-format on
    auto mesh = MeshFactory::create<BoxMesh>(mesh_pars);

    auto prob_pars = GTestFENonlinearProblem::parameters();
    prob_pars.set<App *>("_app", &app);
    prob_pars.set<Mesh *>("mesh", mesh.get());
    GTestFENonlinearProblem problem(prob_pars);
    app.set_problem(&problem);

    auto params = DirichletBC::parameters();
    params.set<App *>("_app", &app);
    params.set<std::vector<std::string>>("boundary", {});
    auto bc = problem.add_boundary_condition<DirichletBC>(params);

    problem.create();

    const auto & components = bc->get_components();
    ASSERT_EQ(components.size(), 1);
    EXPECT_THAT(components, testing::ElementsAre(0));
    EXPECT_EQ(bc->get_field_id(), FieldID(0));

    Real time = 2.5;
    Real x[] = { 3, 5, 7 };
    Scalar u[] = { 0 };

    bc->evaluate(time, x, u);
    EXPECT_EQ(u[0], 37.5);

    bc->evaluate_t(time, x, u);
    EXPECT_EQ(u[0], 1.);
}

TEST(EssentialBCTest, non_existing_field)
{
    testing::internal::CaptureStderr();

    TestApp app;

    Parameters mesh_pars = LineMesh::parameters();
    mesh_pars.set<App *>("_app", &app);
    mesh_pars.set<Int>("nx", 2);
    auto mesh = MeshFactory::create<LineMesh>(mesh_pars);

    Parameters prob_pars = GTest2FieldsFENonlinearProblem::parameters();
    prob_pars.set<App *>("_app", &app);
    prob_pars.set<Mesh *>("mesh", mesh.get());
    GTest2FieldsFENonlinearProblem problem(prob_pars);
    app.set_problem(&problem);

    Parameters params = DirichletBC::parameters();
    params.set<App *>("_app", &app)
        .set<std::string>("field", "asdf")
        .set<std::vector<std::string>>("boundary", {});
    problem.add_boundary_condition<DirichletBC>(params);

    problem.create();

    EXPECT_FALSE(app.check_integrity());
    app.get_logger()->print();

    EXPECT_THAT(testing::internal::GetCapturedStderr(),
                HasSubstr("Field 'asdf' does not exists. Typo?"));
}

TEST(EssentialBCTest, field_param_not_specified)
{
    testing::internal::CaptureStderr();

    TestApp app;

    auto mesh_pars = LineMesh::parameters();
    mesh_pars.set<App *>("_app", &app);
    mesh_pars.set<Int>("nx", 2);
    auto mesh = MeshFactory::create<LineMesh>(mesh_pars);

    auto prob_pars = GTest2FieldsFENonlinearProblem::parameters();
    prob_pars.set<App *>("_app", &app);
    prob_pars.set<Mesh *>("mesh", mesh.get());
    GTest2FieldsFENonlinearProblem problem(prob_pars);
    app.set_problem(&problem);

    auto params = DirichletBC::parameters();
    params.set<App *>("_app", &app);
    params.set<std::vector<std::string>>("boundary", {});
    problem.add_boundary_condition<DirichletBC>(params);

    problem.create();

    EXPECT_FALSE(app.check_integrity());
    app.get_logger()->print();

    EXPECT_THAT(
        testing::internal::GetCapturedStderr(),
        HasSubstr(
            "Use the 'field' parameter to assign this boundary condition to an existing field."));
}
